Operators:
----------
operators: +, -, *, /, %, ^
comparators: ==, !=, <=, >=, <, >
assignment: =, +=, -=, *=, /=
logical: &&, ||, !
unary: ++, --

Types:
------
bool
int, int16, int32, int64
uint, uint16, uint32, uint64
dec32, dec64
char
string is alias of char[]

Tuple type:
-----------
(type1, type2,... typeN)

Function type:
--------------
fn[<tuple type>]:<return type>

Array Type:
-----------
<type>[]

Literals
--------
bool: true false else
char: 'a'
string: "abc"
tuple: (value1, value2,... value N)
array: [value1, value2,... value N)

Variable creation:
------------------
// Mate does not allow nulls so all variables must be explicitly initialized
let <identifier> = <literal>;

Function implementation:
------------------------
def <identifier>[<parameters tuple>] : <return type> {
    <function implementation>
}

Arrays:
-------
let <type>[] <identifier> = <type>[<size>] -> fn(int, int):<type>;
len(<identifier>);

Loops:
------
loop {
}

break[(condition)];
continue[(condition)];

Conditional:
------------
if (cond) {
}

if:
    <Expr 1> { },
    <Expr 2> { },
    ...
    <expr n> { }

// Example:
if:
    x is Person { print("Person"); }
    x is Person? { print("Nobody"); }
    else { print("No Person") }

Structs:
--------
struct

[uses:
    <struct FQN 1>[,
    <struct FQN 2>,
    ...
    <struct FQN N>]
    ]

[extends:
    <extend statements>]

members:
    [<members statements>]


Extend statements:
------------------
<struct name> [{
    <member name> => <new member name>
    ...
}]

Members statements:
-------------------
[<scope statement 1>[, ...<scope statement N>] { ]
    <members definition> | <constants definition>
    ...
}]

Scope statements:
R+ | R- | W+ | W-
(allow | deny) (reads | writes) [only] from <namespace>[..., <namespace>]

Member definition:
<type> <identifier>

Constants definition:
const <type> <identifier> = <literal>


The child struct will inherit all the members of the extended struct.
Inherited members will retain its scope.
In case of naming conflict between members of parent and child structs you can use an alias
to rename certain properties.
By default, (no scope specified) read and writes are allowed for all services
Scope definitions are overriden in the same group (separated by ,) from top to bottom.
Adding the "only" clause on the scope definition is like adding a deny * for the same operation before.

Constants only accept allow / deny read scopes.
Constants must be initialized with a literal (it cannot be an expression)

There are no enums in mate, but you can create with a struct with all constant members and
achieve the same result.

Example:
<Person.mate>
struct

uses:
    mate.example.user.Address

members:
    const MIN_AGE = 16;

    // Can be read everywhere but written only by services in the mate.example.user folder
    // Equivalent to:
    // deny writes from *, allow writes from mate.example.user.*:
    R- *,
    W- *,
    R+ mate.example.user.*
    {
        string name;
        string surname;
        uint age;
        Address address;
    }

<User.mate>
struct

uses
    mate.example.user.Person

extends:
    Person

members:
    // Can be read everywhere
    string userAlias

    // Can only be read by services in the mate.example.user folder, and written only by the
    // mate.examples.user.SignInService
    W- *,
    R- *,
    R+ mate.examples.user.*,
    W+ mate.example.user.SignInService
    {
        string password
    }

Is
--
// Returns true if the identifier is of the specified type or is part of the hierarchy
// of the identifier.
<identifier> is <type>

Empty Type:
-----------
Appending an struct type name with ? is an empty type
The empty type for a given struct will always be it's parent on the inheritance chain.
An empty type has no members.
It can be used on types that can have no value, to actually get the value requires casting.
The empty type does not require initialization

Example:

def main : void {
    // People inherits from People? so this is valid
    People? me

    me is People? // true
    me is People // false

    me = People {
        name: "Fran",
        age: 38
    }

    me is People? // true
    me is People // true

    // Exception because People? doesn't have those members
    me.name = "Pat"
    me.age = 39

    // Works
    if (me is Person) {
        people person = me as Person
        person.name = "Pat"
        person.age = 39
    }

    // Shortcut to the above
    if (me is Person into person) {
        person.name = "Pat"
        person.age = 39
    }
}

Services:
---------
<use clauses>

-------
<runnable.msvc>
void run()

<Runner.msvc>
uses:
    Runnable
    Process1
    Process2

contracts:
    S- *,
    S+ mate.example.* {
        Runnable runnable1 | Process1
        Runnable runnable2 | Process2
    }

functions:
    fn : void run {
        runnable1.run()
        runnable2.run()
    }

<some.msvc>
uses:
    Runner as Main,
    Runner as Secondary,
    ProcessA,
    ProcessB

selects:
    Main {
        runnable1: ProcessA,
        runnable2: ProcessB
    }

functions:
    fn : void main = {
        Main.run()
        Secondary.run()

        Logger.log("finished")
    }

    X- *,
    X+ mate.example.* {
        fn : void inverse = {
            secondary.run();
            main.run();
        }
    }